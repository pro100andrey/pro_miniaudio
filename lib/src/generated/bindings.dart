// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/pro_miniaudio.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class ProMiniaudioBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ProMiniaudioBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ProMiniaudioBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Creates a new Context and initializes the audio system with default
  /// settings.
  result_t audio_context_create() {
    return _audio_context_create();
  }

  late final _audio_context_createPtr =
      _lookup<ffi.NativeFunction<result_t Function()>>('audio_context_create');
  late final _audio_context_create =
      _audio_context_createPtr.asFunction<result_t Function()>();

  /// Checks if the provided Context is valid.
  bool audio_context_is_valid(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_is_valid(
      context,
    );
  }

  late final _audio_context_is_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_is_valid');
  late final _audio_context_is_valid = _audio_context_is_validPtr
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>();

  /// Destroys the Context and releases all associated resources.
  result_t audio_context_destroy(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_destroy(
      context,
    );
  }

  late final _audio_context_destroyPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_destroy');
  late final _audio_context_destroy = _audio_context_destroyPtr
      .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Refreshes the list of available audio devices.
  result_t audio_context_refresh_devices(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_refresh_devices(
      context,
    );
  }

  late final _audio_context_refresh_devicesPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_refresh_devices');
  late final _audio_context_refresh_devices = _audio_context_refresh_devicesPtr
      .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Gets the number of available playback devices.
  result_t audio_context_get_playback_device_count(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_get_playback_device_count(
      context,
    );
  }

  late final _audio_context_get_playback_device_countPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_get_playback_device_count');
  late final _audio_context_get_playback_device_count =
      _audio_context_get_playback_device_countPtr
          .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Gets the number of available capture devices.
  result_t audio_context_get_capture_device_count(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_get_capture_device_count(
      context,
    );
  }

  late final _audio_context_get_capture_device_countPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_get_capture_device_count');
  late final _audio_context_get_capture_device_count =
      _audio_context_get_capture_device_countPtr
          .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Gets information about available playback devices.
  result_t audio_context_get_playback_devices_info(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_get_playback_devices_info(
      context,
    );
  }

  late final _audio_context_get_playback_devices_infoPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_get_playback_devices_info');
  late final _audio_context_get_playback_devices_info =
      _audio_context_get_playback_devices_infoPtr
          .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Gets information about available capture devices.
  result_t audio_context_get_capture_devices_info(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _audio_context_get_capture_devices_info(
      context,
    );
  }

  late final _audio_context_get_capture_devices_infoPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'audio_context_get_capture_devices_info');
  late final _audio_context_get_capture_devices_info =
      _audio_context_get_capture_devices_infoPtr
          .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Gets the number of bytes per sample for the given format.
  int get_bytes_per_sample(
    sample_format_t format,
  ) {
    return _get_bytes_per_sample(
      format.value,
    );
  }

  late final _get_bytes_per_samplePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt)>>(
          'get_bytes_per_sample');
  late final _get_bytes_per_sample =
      _get_bytes_per_samplePtr.asFunction<int Function(int)>();

  /// Gets the number of bytes per frame for the given format and channel count.
  int get_bytes_per_frame(
    sample_format_t format,
    int channels,
  ) {
    return _get_bytes_per_frame(
      format.value,
      channels,
    );
  }

  late final _get_bytes_per_framePtr = _lookup<
          ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt, ffi.Uint32)>>(
      'get_bytes_per_frame');
  late final _get_bytes_per_frame =
      _get_bytes_per_framePtr.asFunction<int Function(int, int)>();

  /// Enable or disable logging to a file.
  void set_log_to_file_enabled(
    bool enabled,
  ) {
    return _set_log_to_file_enabled(
      enabled,
    );
  }

  late final _set_log_to_file_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'set_log_to_file_enabled');
  late final _set_log_to_file_enabled =
      _set_log_to_file_enabledPtr.asFunction<void Function(bool)>();

  /// Check if logging to a file is enabled.
  bool is_log_to_file_enabled() {
    return _is_log_to_file_enabled();
  }

  late final _is_log_to_file_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'is_log_to_file_enabled');
  late final _is_log_to_file_enabled =
      _is_log_to_file_enabledPtr.asFunction<bool Function()>();

  /// Initialize logging to a file.
  void init_log(
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _init_log(
      filename,
    );
  }

  late final _init_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'init_log');
  late final _init_log =
      _init_logPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Close the log file.
  void close_log() {
    return _close_log();
  }

  late final _close_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('close_log');
  late final _close_log = _close_logPtr.asFunction<void Function()>();

  /// Enable or disable logging to the console.
  void set_log_to_console_enabled(
    bool enabled,
  ) {
    return _set_log_to_console_enabled(
      enabled,
    );
  }

  late final _set_log_to_console_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'set_log_to_console_enabled');
  late final _set_log_to_console_enabled =
      _set_log_to_console_enabledPtr.asFunction<void Function(bool)>();

  /// Log a message with a specified level.
  void log_message(
    LogLevel level,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _log_message(
      level.value,
      format,
    );
  }

  late final _log_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>>('log_message');
  late final _log_message =
      _log_messagePtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Creates a playback device with the specified parameters.
  result_t playback_device_create(
    ffi.Pointer<ffi.Void> pAudioContext,
    int bufferSizeInBytes,
    device_id_t deviceId,
    supported_format_t supportedFormat,
  ) {
    return _playback_device_create(
      pAudioContext,
      bufferSizeInBytes,
      deviceId,
      supportedFormat,
    );
  }

  late final _playback_device_createPtr = _lookup<
      ffi.NativeFunction<
          result_t Function(ffi.Pointer<ffi.Void>, ffi.Size, device_id_t,
              supported_format_t)>>('playback_device_create');
  late final _playback_device_create = _playback_device_createPtr.asFunction<
      result_t Function(
          ffi.Pointer<ffi.Void>, int, device_id_t, supported_format_t)>();

  /// Destroys a playback device and releases its resources.
  result_t playback_device_destroy(
    ffi.Pointer<ffi.Void> device,
  ) {
    return _playback_device_destroy(
      device,
    );
  }

  late final _playback_device_destroyPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'playback_device_destroy');
  late final _playback_device_destroy = _playback_device_destroyPtr
      .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Starts playback on the device.
  result_t playback_device_start(
    ffi.Pointer<ffi.Void> device,
  ) {
    return _playback_device_start(
      device,
    );
  }

  late final _playback_device_startPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'playback_device_start');
  late final _playback_device_start = _playback_device_startPtr
      .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Stops playback on the device.
  result_t playback_device_stop(
    ffi.Pointer<ffi.Void> device,
  ) {
    return _playback_device_stop(
      device,
    );
  }

  late final _playback_device_stopPtr =
      _lookup<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>(
          'playback_device_stop');
  late final _playback_device_stop = _playback_device_stopPtr
      .asFunction<result_t Function(ffi.Pointer<ffi.Void>)>();

  /// Pushes audio data to the playback device's buffer.
  result_t playback_device_push_buffer(
    ffi.Pointer<ffi.Void> device,
    ffi.Pointer<playback_data_t> data,
  ) {
    return _playback_device_push_buffer(
      device,
      data,
    );
  }

  late final _playback_device_push_bufferPtr = _lookup<
      ffi.NativeFunction<
          result_t Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<playback_data_t>)>>('playback_device_push_buffer');
  late final _playback_device_push_buffer =
      _playback_device_push_bufferPtr.asFunction<
          result_t Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<playback_data_t>)>();

  /// Creates a waveform generator with the specified parameters.
  result_t waveform_create(
    sample_format_t format,
    int channels,
    int sampleRate,
    waveform_type_t waveformType,
    double amplitude,
    double frequency,
  ) {
    return _waveform_create(
      format.value,
      channels,
      sampleRate,
      waveformType.value,
      amplitude,
      frequency,
    );
  }

  late final _waveform_createPtr = _lookup<
      ffi.NativeFunction<
          result_t Function(ffi.UnsignedInt, ffi.Uint32, ffi.Uint32,
              ffi.UnsignedInt, ffi.Double, ffi.Double)>>('waveform_create');
  late final _waveform_create = _waveform_createPtr
      .asFunction<result_t Function(int, int, int, int, double, double)>();

  /// Destroys a waveform generator and releases its resources.
  void waveform_destroy(
    ffi.Pointer<ffi.Void> waveform,
  ) {
    return _waveform_destroy(
      waveform,
    );
  }

  late final _waveform_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'waveform_destroy');
  late final _waveform_destroy =
      _waveform_destroyPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Reads PCM frames from the waveform generator.
  result_t waveform_read_pcm_frames_with_buffer(
    ffi.Pointer<ffi.Void> waveform,
    ffi.Pointer<ffi.Void> pFramesOut,
    int framesCount,
    ffi.Pointer<ffi.Uint64> pFramesRead,
  ) {
    return _waveform_read_pcm_frames_with_buffer(
      waveform,
      pFramesOut,
      framesCount,
      pFramesRead,
    );
  }

  late final _waveform_read_pcm_frames_with_bufferPtr = _lookup<
          ffi.NativeFunction<
              result_t Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint64, ffi.Pointer<ffi.Uint64>)>>(
      'waveform_read_pcm_frames_with_buffer');
  late final _waveform_read_pcm_frames_with_buffer =
      _waveform_read_pcm_frames_with_bufferPtr.asFunction<
          result_t Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Uint64>)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final ProMiniaudioBindings _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>
      get audio_context_destroy => _library._audio_context_destroyPtr;
  ffi.Pointer<ffi.NativeFunction<result_t Function(ffi.Pointer<ffi.Void>)>>
      get playback_device_destroy => _library._playback_device_destroyPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      get waveform_destroy => _library._waveform_destroyPtr;
}

/// Union to store device identifiers for different audio backends.
final class device_id_t extends ffi.Union {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedShort> wasapi;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> dsound;

  @ffi.UnsignedInt()
  external int winmm;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> alsa;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> pulse;

  @ffi.Int()
  external int jack;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> coreaudio;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> sndio;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> audio4;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> oss;

  @ffi.Int()
  external int aaudio;

  @ffi.UnsignedInt()
  external int opensl;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> webaudio;

  external UnnamedUnion1 custom;

  @ffi.Int()
  external int nullbackend;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int()
  external int i;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> s;

  external ffi.Pointer<ffi.Void> p;
}

/// Enum to represent supported audio sample formats.
enum sample_format_t {
  sample_format_unknown(0),
  sample_format_u8(1),
  sample_format_s16(2),
  sample_format_s24(3),
  sample_format_s32(4),
  sample_format_f32(5),
  sample_format_count(6);

  final int value;
  const sample_format_t(this.value);

  static sample_format_t fromValue(int value) => switch (value) {
        0 => sample_format_unknown,
        1 => sample_format_u8,
        2 => sample_format_s16,
        3 => sample_format_s24,
        4 => sample_format_s32,
        5 => sample_format_f32,
        6 => sample_format_count,
        _ => throw ArgumentError("Unknown value for sample_format_t: $value"),
      };
}

/// Structure to describe a supported audio data format.
final class supported_format_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int formatAsInt;

  sample_format_t get format => sample_format_t.fromValue(formatAsInt);

  @ffi.Uint32()
  external int channels;

  @ffi.Uint32()
  external int sampleRate;

  @ffi.Uint32()
  external int flags;
}

/// Structure to describe an audio device.
final class device_info_t extends ffi.Struct {
  external device_id_t id;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> name;

  @ffi.Bool()
  external bool isDefault;

  @ffi.Uint32()
  external int dataFormatCount;

  @ffi.Array.multi([64])
  external ffi.Array<supported_format_t> dataFormats;
}

/// Structure to represent the result of a function call.
final class result_t extends ffi.Struct {
  external result_data_t data;

  @ffi.UnsignedInt()
  external int typeAsInt;

  data_type_t get type => data_type_t.fromValue(typeAsInt);

  @ffi.UnsignedInt()
  external int codeAsInt;

  error_code_t get code => error_code_t.fromValue(codeAsInt);

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> message;
}

/// Union to store different types of result data.
final class result_data_t extends ffi.Union {
  external ffi.Pointer<ffi.Void> pData;

  @ffi.Int32()
  external int intData;

  @ffi.Float()
  external double floatData;
}

/// Enum to represent the type of data stored in a `result_t`.
enum data_type_t {
  data_type_empty(0),
  data_type_int(1),
  data_type_ptr(2);

  final int value;
  const data_type_t(this.value);

  static data_type_t fromValue(int value) => switch (value) {
        0 => data_type_empty,
        1 => data_type_int,
        2 => data_type_ptr,
        _ => throw ArgumentError("Unknown value for data_type_t: $value"),
      };
}

/// Error codes for function results.
enum error_code_t {
  error_code_none(0),
  error_code_unknown(1),
  error_code_context(2),
  error_code_device(3),
  error_code_get_device(5),
  error_code_get_device_info(6),
  error_code_buffer(7),
  error_waveform(8);

  final int value;
  const error_code_t(this.value);

  static error_code_t fromValue(int value) => switch (value) {
        0 => error_code_none,
        1 => error_code_unknown,
        2 => error_code_context,
        3 => error_code_device,
        5 => error_code_get_device,
        6 => error_code_get_device_info,
        7 => error_code_buffer,
        8 => error_waveform,
        _ => throw ArgumentError("Unknown value for error_code_t: $value"),
      };
}

enum LogLevel {
  LOG_LEVEL_DEBUG(0),
  LOG_LEVEL_INFO(1),
  LOG_LEVEL_ERROR(2);

  final int value;
  const LogLevel(this.value);

  static LogLevel fromValue(int value) => switch (value) {
        0 => LOG_LEVEL_DEBUG,
        1 => LOG_LEVEL_INFO,
        2 => LOG_LEVEL_ERROR,
        _ => throw ArgumentError("Unknown value for LogLevel: $value"),
      };
}

/// Structure to represent data being pushed to a playback device.
final class playback_data_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int formatAsInt;

  sample_format_t get format => sample_format_t.fromValue(formatAsInt);

  external ffi.Pointer<ffi.Void> pUserData;

  @ffi.Uint32()
  external int sizeInBytes;
}

/// Enum representing different types of waveforms.
enum waveform_type_t {
  waveform_type_sine(0),
  waveform_type_square(1),
  waveform_type_triangle(2),
  waveform_type_sawtooth(3);

  final int value;
  const waveform_type_t(this.value);

  static waveform_type_t fromValue(int value) => switch (value) {
        0 => waveform_type_sine,
        1 => waveform_type_square,
        2 => waveform_type_triangle,
        3 => waveform_type_sawtooth,
        _ => throw ArgumentError("Unknown value for waveform_type_t: $value"),
      };
}

const int MAX_DEVICE_NAME_LENGTH = 255;
